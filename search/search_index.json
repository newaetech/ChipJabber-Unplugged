{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ChipJabber\u2122-Unplugged is a voltage fault injection tool by NewAE Technology Inc . It's the voltage glitch tool that you can build yourself, and features not a single piece of programmable logic anywhere in sight . This device was discussed in detail in the July 2020 issue of Circuit Cellar . See the pages on menu at left for more details of how it works, and see the GITHub Repository for relevant design documents. The objective of this project is to teach you about voltage fault injection & how easily it can be performed. When you go to do real work you probably want some programmable logic to make it easier to sweep glitch parameters and settings, without spending all your time tweaking knobs. You can check out the ChipWhisperer project & the ChipSHOUTER tools for more advanced fault injection tools, and the ChipWhisperer.io Online Training might be of interest to you to understand how this all works. Warning This repo is still a work in progress. The uploaded material currently supports the Circuit Cellar article. More details of the full kits is coming shortly, check back soon. Annoucements will come via NewAE Technology's low-volume newsletter . Info Check out the Crowd-Supply Page for more details. Currently it's just a blank sign-up to be notified when kits are available! Variants \u00b6 There are three versions of ChipJabber-Unplugged, which use almost the same architectures (only some minor differences): ChipJabber-Unplugged Kit : This kit is a classic electronics kit, using almost all through-hole electronics parts. You can build this design on a breadboard or perfboard as well if you wish using the provided schematic. ChipJabber-Unplugged Mini : This is a pre-built unit, using surface-mount electronics to make a much smaller version. Not available as a kit due to the hassle of making SMD kits (sorry). ChipJabber-Unplugged Old-School PCB : This board is designed to be built with home-etch boards (minimal number of vias), or a PCB mill such as the Bantam PCB Mill. It's a slightly simplified version of the normal ChipJabber-Unplugged. The board exactly fits the Bantam PCB Mill working area. ChipJabber-Unplugged Kit \u00b6 ChipJabber-Unplugged Mini \u00b6 Need to glitch on the go, but still want to twiddle those settings physically? No worries, ChipJabber-Unplugged Mini is slightly larger than the 3x AA batteries powering it, and features excessively large \"slider\" style potentiometers. Here's an early photo of it: ChipJabber-Unplugged Home-Etch PCB \u00b6 Firing up the tank of ferrochloric acid, or spinning up your PCB mill? A special edition of the board is done with double-sided logic, but minimizing the number of vias Tools \u00b6 Any of the glitchers can be used in combination with some other cool tools as part of the project: NOTDuino Secure Boot \u00b6 Now that you've got a glitcher, what do you do? While we include the NOTDuino \"Secure Boot\" demo board, which uses a very simple EEPROM as a \"key\" to validate the boot process. This board is can be programmed via the Arduino IDE by plugging in a serial-to-USB adapter, such as the DIPUSB tool below. DIPUSB \u00b6 How are you going to talk 3.3V serial to your device? No worry, the all-through-hole DIPUSB adapter will work for you: Real-Life Usage \u00b6 ChipJabber-Unplugged is designed more for fun than \"real-life\" usage. But - you can do real stuff with it. Why not recreate Chris Gerlinsky 's LPC Code Read Protection attack ? ChipJabber is a trademark of NewAE Technology Inc. This documentation is built using MkDocs and Material for MkDocs .","title":"ChipJabber-Unplugged Overview"},{"location":"#variants","text":"There are three versions of ChipJabber-Unplugged, which use almost the same architectures (only some minor differences): ChipJabber-Unplugged Kit : This kit is a classic electronics kit, using almost all through-hole electronics parts. You can build this design on a breadboard or perfboard as well if you wish using the provided schematic. ChipJabber-Unplugged Mini : This is a pre-built unit, using surface-mount electronics to make a much smaller version. Not available as a kit due to the hassle of making SMD kits (sorry). ChipJabber-Unplugged Old-School PCB : This board is designed to be built with home-etch boards (minimal number of vias), or a PCB mill such as the Bantam PCB Mill. It's a slightly simplified version of the normal ChipJabber-Unplugged. The board exactly fits the Bantam PCB Mill working area.","title":"Variants"},{"location":"#chipjabber-unplugged-kit","text":"","title":"ChipJabber-Unplugged Kit"},{"location":"#chipjabber-unplugged-mini","text":"Need to glitch on the go, but still want to twiddle those settings physically? No worries, ChipJabber-Unplugged Mini is slightly larger than the 3x AA batteries powering it, and features excessively large \"slider\" style potentiometers. Here's an early photo of it:","title":"ChipJabber-Unplugged Mini"},{"location":"#chipjabber-unplugged-home-etch-pcb","text":"Firing up the tank of ferrochloric acid, or spinning up your PCB mill? A special edition of the board is done with double-sided logic, but minimizing the number of vias","title":"ChipJabber-Unplugged Home-Etch PCB"},{"location":"#tools","text":"Any of the glitchers can be used in combination with some other cool tools as part of the project:","title":"Tools"},{"location":"#notduino-secure-boot","text":"Now that you've got a glitcher, what do you do? While we include the NOTDuino \"Secure Boot\" demo board, which uses a very simple EEPROM as a \"key\" to validate the boot process. This board is can be programmed via the Arduino IDE by plugging in a serial-to-USB adapter, such as the DIPUSB tool below.","title":"NOTDuino Secure Boot"},{"location":"#dipusb","text":"How are you going to talk 3.3V serial to your device? No worry, the all-through-hole DIPUSB adapter will work for you:","title":"DIPUSB"},{"location":"#real-life-usage","text":"ChipJabber-Unplugged is designed more for fun than \"real-life\" usage. But - you can do real stuff with it. Why not recreate Chris Gerlinsky 's LPC Code Read Protection attack ? ChipJabber is a trademark of NewAE Technology Inc. This documentation is built using MkDocs and Material for MkDocs .","title":"Real-Life Usage"},{"location":"notduino-sb/","text":"The NOTDuino was originally part of the ChipWhisperer-Lite Kickstarter campaign. This is extended to now work as a \"secure boot\" demo board. The \"secure boot\" isn't really that secure, as the default version of it looks just for a special I2C EEPROM magic value. Background \u00b6 Boot Process Summary \u00b6 The NOTDuino boot process is as follows: Check if I2C bus appears to be available (not stuck). If bus is stuck, we stop boot. Try talking to an I2C EEPROM at address 0x50 , and read address 0xA7 . If the read fails, stop boot. Check that address 0xA7 is set to magic value 0xDE . If this is true, continue boot, otherwise stop boot. The I2C socket is designed to also accept a XXXX device, which would be closer to a more relevant secure device. Unfortunately shipping those devices triggers certain export rules, so we instead use the simple EEPROM in the kit. Application Code \u00b6 If the boot succeeds, the following code is run in a loop: cnt = 0 ; for ( i = 0 ; i < 200 ; i ++ ){ for ( j = 0 ; j < 200 ; j ++ ){ cnt ++ ; } } if ( cnt == 40000 ){ digitalWrite ( LED_NORMAL , HIGH ); } else { digitalWrite ( LED_GLITCH , HIGH ); } This should result in the NORMAL blinking green. If you see the GLITCH blink red, it means you have successfully glitched the code, without crashing the target device! Glitching the Boot \u00b6 Once you get a useful glitch, you should try glitching secure boot. Insert the jumper at SH3 which shorts the I2C line, thus disabling the key (same as if the EEPROM was removed or loaded with incorrect data). The device will now lite the FAIL boot LED. Oh no! If you looked at the code, the implementation works like this: if ( boot_ok () == 0 ) { digitalWrite ( LED_FAIL , HIGH ); Serial . print ( \"Boot FAILED - application blocked \\n \" ); while ( 1 ); } else { digitalWrite ( LED_OK , HIGH ); Serial . print ( \"Boot OK \\n \" ); } Glitching Manually \u00b6 The first thing you can do is use the push-button trigger on the ChipJabber-Unplugged, and simply try glitching out of the while(1) loop. If you are successful, you'll see the NORMAL LED start flashing as the application is now running. The boot will still be marked as FAIL , since we didn't actually bypass the boot check, just glitched out of the loop. Glitching Automatically \u00b6 Using the PCB trace going to LED1, you can solder a pin header into one of the vias. This will now be used as a trigger for a rising-edge input trigger. You'll have to experiment with the delay setting, but you should be able to get the device to automatically start running the application after a reset. Use the reset switch ( SW1 ) to keep resetting the device. Building the Kit \u00b6 Errata \u00b6 Note in the various photos 3.3K resistors are used in place of 10K, as I ran out of 10K when I built this. Will be fixed in later photos.","title":"NOTduino Secure Boot Demo Board"},{"location":"notduino-sb/#background","text":"","title":"Background"},{"location":"notduino-sb/#boot-process-summary","text":"The NOTDuino boot process is as follows: Check if I2C bus appears to be available (not stuck). If bus is stuck, we stop boot. Try talking to an I2C EEPROM at address 0x50 , and read address 0xA7 . If the read fails, stop boot. Check that address 0xA7 is set to magic value 0xDE . If this is true, continue boot, otherwise stop boot. The I2C socket is designed to also accept a XXXX device, which would be closer to a more relevant secure device. Unfortunately shipping those devices triggers certain export rules, so we instead use the simple EEPROM in the kit.","title":"Boot Process Summary"},{"location":"notduino-sb/#application-code","text":"If the boot succeeds, the following code is run in a loop: cnt = 0 ; for ( i = 0 ; i < 200 ; i ++ ){ for ( j = 0 ; j < 200 ; j ++ ){ cnt ++ ; } } if ( cnt == 40000 ){ digitalWrite ( LED_NORMAL , HIGH ); } else { digitalWrite ( LED_GLITCH , HIGH ); } This should result in the NORMAL blinking green. If you see the GLITCH blink red, it means you have successfully glitched the code, without crashing the target device!","title":"Application Code"},{"location":"notduino-sb/#glitching-the-boot","text":"Once you get a useful glitch, you should try glitching secure boot. Insert the jumper at SH3 which shorts the I2C line, thus disabling the key (same as if the EEPROM was removed or loaded with incorrect data). The device will now lite the FAIL boot LED. Oh no! If you looked at the code, the implementation works like this: if ( boot_ok () == 0 ) { digitalWrite ( LED_FAIL , HIGH ); Serial . print ( \"Boot FAILED - application blocked \\n \" ); while ( 1 ); } else { digitalWrite ( LED_OK , HIGH ); Serial . print ( \"Boot OK \\n \" ); }","title":"Glitching the Boot"},{"location":"notduino-sb/#glitching-manually","text":"The first thing you can do is use the push-button trigger on the ChipJabber-Unplugged, and simply try glitching out of the while(1) loop. If you are successful, you'll see the NORMAL LED start flashing as the application is now running. The boot will still be marked as FAIL , since we didn't actually bypass the boot check, just glitched out of the loop.","title":"Glitching Manually"},{"location":"notduino-sb/#glitching-automatically","text":"Using the PCB trace going to LED1, you can solder a pin header into one of the vias. This will now be used as a trigger for a rising-edge input trigger. You'll have to experiment with the delay setting, but you should be able to get the device to automatically start running the application after a reset. Use the reset switch ( SW1 ) to keep resetting the device.","title":"Glitching Automatically"},{"location":"notduino-sb/#building-the-kit","text":"","title":"Building the Kit"},{"location":"notduino-sb/#errata","text":"Note in the various photos 3.3K resistors are used in place of 10K, as I ran out of 10K when I built this. Will be fixed in later photos.","title":"Errata"},{"location":"ChipJabber-Unplugged/arch/","text":"","title":"Architecture"},{"location":"ChipJabber-Unplugged/cj-02-main-kit/","text":"Electronics Kit \u00b6 Parts \u00b6 Blank PCB \u00b6 The blank PCB is marked with the mounting information for most parks. The following notation is used: 330R: a 330-ohm 1/4W resistor. 104: a 100nF capacitor. The part code should match what is used on the capacitor, where 104 means \"10 x 10000\" = 100000pF = 100nF for example. See more details on general electronics parts notes. Surface Mount Parts \u00b6 There are two surface-mount parts used. You can actually skip installing the parts if you wish (if you are not comfortable soldering SMD parts). If you do not install them, note the following: Q1: If Q1 is not installed, the \"crowbar\" output is not available. This means SW7 should be set to MUX mode always. Q2: Diode D1 must be installed if Q2 is not installed. Diode D1 provides reverse polarity protection, but has a small voltage drop that limits your maximum voltage. Installing Q2 means you have almost no voltage drop, and can output a slightly higher maximum voltage.","title":"Complete Kit"},{"location":"ChipJabber-Unplugged/cj-02-main-kit/#electronics-kit","text":"","title":"Electronics Kit"},{"location":"ChipJabber-Unplugged/cj-02-main-kit/#parts","text":"","title":"Parts"},{"location":"ChipJabber-Unplugged/cj-02-main-kit/#blank-pcb","text":"The blank PCB is marked with the mounting information for most parks. The following notation is used: 330R: a 330-ohm 1/4W resistor. 104: a 100nF capacitor. The part code should match what is used on the capacitor, where 104 means \"10 x 10000\" = 100000pF = 100nF for example. See more details on general electronics parts notes.","title":"Blank PCB"},{"location":"ChipJabber-Unplugged/cj-02-main-kit/#surface-mount-parts","text":"There are two surface-mount parts used. You can actually skip installing the parts if you wish (if you are not comfortable soldering SMD parts). If you do not install them, note the following: Q1: If Q1 is not installed, the \"crowbar\" output is not available. This means SW7 should be set to MUX mode always. Q2: Diode D1 must be installed if Q2 is not installed. Diode D1 provides reverse polarity protection, but has a small voltage drop that limits your maximum voltage. Installing Q2 means you have almost no voltage drop, and can output a slightly higher maximum voltage.","title":"Surface Mount Parts"},{"location":"ChipJabber-Unplugged/cj-03-mini/","text":"","title":"Mini Version"},{"location":"ChipJabber-Unplugged/cj-04-simplepcb/","text":"","title":"Simple PCB Version"}]}